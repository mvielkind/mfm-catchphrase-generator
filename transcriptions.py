import os
import boto3
import json
import numpy as np
from dotenv import load_dotenv
load_dotenv()


def transcribe_recording(file_name, transcript_label):
    """
    Loads a file to S3 and begins the AWS Transcribe job.
    :param file_name: Name of the file as saved locally.
    :param transcript_label: Label to apply to the episode transcription.
    """
    s3_key = f"recordings/{file_name}"

    # Load to S3.
    load_recording_to_s3(file_name)

    # Start the transcription job.
    start_transcribe_recording_job(s3_key, transcript_label)


def process_transcript(transcript_label):
    """
    Once an episode is transcribed the transcript is processed and uploaded to S3.
    :param transcript_label: S3 key for the transcript output.
    """
    transcript_key = f"{transcript_label}.json"

    # Load Transcribe output from S3.
    raw_transcript = get_transcribe_output(transcript_key)

    # Parse to assign speaker parts.
    speaker_parts = assign_speakers(raw_transcript)

    # Identify Karen and Georgia.
    assigned = karen_or_georgia(speaker_parts)

    # Update the full transcript.
    build_transcript(assigned)

    # Upload the latest transcript to S3.
    s3 = boto3.resource("s3")
    s3.Bucket(os.getenv("S3_BUCKET")).upload_file("main_transcript.txt", "main_transcript.txt")


def load_recording_to_s3(file_name):
    """
    Loads the recording file to a S3 bucket so it can be used with AWS Transcribe.
    :param file_name: Name of the file to upload.
    """
    s3 = boto3.client("s3")

    s3.upload_file(f"{os.getenv('RECORDING_LOC')}/{file_name}",
                   Bucket=os.getenv("S3_BUCKET"),
                   Key=f"recordings/{file_name}")


def start_transcribe_recording_job(recording_key, job_name):
    """
    Start an AWS Transcribe recording job.
    :param recording_key: S3 key of the recording to be transcribed.
    :param job_name: S3 key to assign to the Transcribe output.
    """
    transcribe = boto3.client('transcribe')

    response = transcribe.start_transcription_job(
        TranscriptionJobName=job_name,
        LanguageCode='en-US',
        MediaFormat='mp3',
        Media={
            'MediaFileUri': f's3://{os.getenv("S3_BUCKET")}/{recording_key}'
        },
        OutputBucketName='mfm-bot-recordings',
        Settings={
            'VocabularyName': 'mfm-vocab',
            'ShowSpeakerLabels': True,
            'MaxSpeakerLabels': 2
        }
    )


def get_transcribe_output(key):
    """
    Downloads the raw output file generated by Transcribe.
    :param key: S3 key of the Transcribe output to download.
    :return: Object of the Transcribe output.
    """
    s3 = boto3.client('s3')

    obj = s3.get_object(Bucket=os.getenv("S3_BUCKET"), Key=key)

    return json.loads(obj["Body"].read())


def assign_speakers(transcript):
    """
    Maps labeled speaker timestamps to the words spoken during the timestamp.
    :return: List of labeled speakers and their content.
    """
    speaker_time_labels = {seg["start_time"]: seg["speaker_label"] for seg in
                           transcript["results"]["speaker_labels"]["segments"]}

    speaker_transcript = []
    speaker = None
    current_line = ''

    for i in transcript["results"]["items"]:
        # What was said.
        content = i["alternatives"][0]["content"]
        # Check if the current speaker has changed. Otherwise keep the same speaker.
        try:
            current_speaker = speaker_time_labels[i["start_time"]]

            if speaker:
                if speaker != current_speaker:
                    speaker_transcript.append({"speaker": speaker, "content": current_line})
                    current_line = ''
        except KeyError:
            current_speaker = speaker

            # Check if punctuation.
        if i["type"] == "punctuation":
            current_line += content
        elif current_line == '':
            current_line += content
        else:
            current_line += f' {content}'

        speaker = current_speaker

    return speaker_transcript


def karen_or_georgia(speaker_transcript):
    """
    Use mentions of names to label who is speaking, either Karen or Georgia.

    Assumption is made that a person will use someone else's name more often than their own.
    :param speaker_transcript: Mapped speaker transcript.
    :return: Transcript with speaker labels changed to Karen / Georgia.
    """
    # Create a matrix to track number of mentions.
    mention_matrix = np.zeros((2, 2))

    for i, t in enumerate(speaker_transcript):
        speaker = t["speaker"]
        speaker_idx = int(speaker[-1])

        mention_matrix[0][speaker_idx] += t["content"].lower().count("georgia")
        mention_matrix[1][speaker_idx] += t["content"].lower().count("karen")

    mention_ratio = mention_matrix / np.sum(mention_matrix, axis=1)[:, None]

    # Find the biggest ratio and assign speakers.
    top_mention = np.argmax(mention_ratio)

    speaker_map = {}
    if top_mention in [0, 2]:
        speaker_map["spk_0"] = "KAREN"
        speaker_map["spk_1"] = "GEORGIA"
    elif top_mention in [1, 3]:
        speaker_map["spk_0"] = "GEORGIA"
        speaker_map["spk_1"] = "KAREN"

    # Replace speaker labels in the transcript with new labels.
    for s in speaker_transcript:
        s["speaker"] = speaker_map[s["speaker"]]

    return speaker_transcript


def build_transcript(speaker_label_transcript):
    """
    Append the new speaker transcript to the local transcript file.
    :param speaker_label_transcript: Transcript with speaker labels changed to Karen / Georgia.
    """
    with open('main_transcript.txt', 'a') as the_file:
        for t in speaker_label_transcript:
            the_file.write(f"{t['speaker']}:\n")
            the_file.write(f"{t['content']}\n\n")
